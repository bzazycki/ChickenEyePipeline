---
title: "3_Chicken_Eye_R_Clustering.Rmd"
output: html_document
---

# Chicken Eye: Clustering 

Date: July 14 2025

Author: Ben Zazycki

Adapted from: Jared Tangeman

Professor: Dr. Chun Liang

## Workspace Setup

Load packages from library:

```{r}
library(Seurat)
library(Signac)
library(ggpubr)
library(ggplot2)
library(future)
library(DT)
library(gprofiler2)
library(scCustomize)
library(Matrix)
library(plotly)
library(ensembldb)
library(JASPAR2024)
library(DirichletMultinomial)
library(TFBSTools)
library(motifmatchr)
library(chromVAR)
library(ggforce)
library(GenomicRanges)
library(BSgenomeForge)
library(BSgenome)
library(biovizBase)
library(patchwork)
library(glmGamPoi)
library(presto)
library(GenomeInfoDb)
library(Biostrings)
library(rtracklayer)
library(BSgenome.Ggallus.ensembl.GRCg7b)
```

Load in Seurat object and annotation from previous notebook. I will name the Seurat object 'seu' here because it's the only one I'm working with in this notebook.

```{r}
rds_input_path <- '/Users/benzazycki/Documents/Research/ChickenEye/Outputs/notebook_2/'
seu <- readRDS(paste0(rds_input_path, "seu_merged_processed.rds"))
annotation <- readRDS(paste0(rds_input_path, "annotation.rds"))
```

## Initial Clustering/UMAP Reduction

Run PCA for dimensionality reduction:

```{r}
seu <- RunPCA(seu, features = VariableFeatures(object = seu))
```

Create elbow plot to judge effectiveness of PCs:

```{r}
ElbowPlot(seu, ndims = 50)
```

Run KNN:

```{r}
seu <- FindNeighbors(seu, reduction = "pca", dims = 1:50)
```

Run default clustering algorithm. This will use Louvain.

```{r}
seu <- FindClusters(seu, cluster.name = "RNA_clusters")
```

Run UMAP reduction:

```{r}
seu <- RunUMAP(seu, dims = 1:50, 
               reduction.name = "umap.rna", reduction.key = "rnaUMAP_")
```

View simple UMAP visualization:

```{r}
DimPlot(seu, reduction = "umap.rna", group.by = "RNA_clusters")
```

## ATAC Analysis

Run Term Frequency-Inverse Document Frequency Normalization to increase contrast:

```{r}
DefaultAssay(seu) <- "ATAC"
seu_merged <- RunTFIDF(seu, assay = "ATAC")
```

Filter to peaks that are in at least 5 cells:

```{r}
seu <- FindTopFeatures(seu, min.cutoff = 5)
```

Run Singular Value Decomposition to project onto fewer dimensions:

```{r}
seu <- RunSVD(seu)
```

NOTE: I will use the terms SVD (Singular Value Decomposion) and LSI (Latent Semantic Indexint) interchangably in this notebook; they mean the same thing.

Check correlation of LSI components with sequencing depth:

```{r}
DepthCor(seu)
```

Visualize the variance explained by each LSI dimension:

```{r}
ElbowPlot(seu, reduction = "lsi", ndims = 50)
```

In ATAC data, LSI dimension 1 is often captures technical variation (in this case, sequencing depth). It is not a biologically meaningful dimension, and it will be excluded from future analysis.

Construct KNN:

```{r}
seu <- FindNeighbors(object = seu, reduction = 'lsi', dims = 2:30)
```

Run clustering algorithm. 'algorithm = 3' specifies using SLM instead of Louvain here.

```{r}
seu <- FindClusters(object = seu,
                    algorithm = 3, cluster.name = "ATAC_clusters")
```

Run UMAP:

```{r}
seu <- RunUMAP(seu, reduction = 'lsi', dims = 2:30,
                        assay = "ATAC", slot = "data",
                        reduction.name = "umap.atac",
                        reduction.key = "atacUMAP_",
                        group.by = "ATAC_clusters")
```

Simple UMAP visualization:

```{r}
DimPlot(seu, reduction = "umap.atac", group.by = "ATAC_clusters")
```

## Calling Peaks

We are using a tool called MACS2 to detect regions of open chromatin (called "peaks") in single-cell ATAC-seq data. Instead of calling peaks on all cells together, we are doing it separately for each group of cells, where groups are defined by their RNA expression patterns — this can reveal more specific, meaningful regulatory features.

Once those peaks are identified, we are cleaning and formatting the data so it lines up properly with the chicken genome reference, making sure all coordinates are valid and interpretable. Then, we are building a new dataset that counts how many ATAC-seq reads fall into each peak for each cell — like a big table showing which regions of the genome are open in which cells.

Finally, we create a new "assay" within your data object that stores this information, so we can use it later to study differences in chromatin accessibility between cell types.

First, install MACS2 and find its location within the colab environment:

```{bash}
pip install MACS2
which macs2
```

Then, using that path from above, run the Signac CallPeaks method. Note: effective genome size is specific to each species and is hardcoded here for chicken data.

```{r}
peaks <- CallPeaks(object = seu,
                   group.by = "RNA_clusters",
                   effective.genome.size = 1049948333,
                   macs2.path = "ENTER HERE",
                   assay = "ATAC")
```

Extract the 3 important columns from 'peaks' and rename them to be more descriptive:

```{r}
peaksFormatted <- data.frame(peaks)[,1:3]
colnames(peaksFormatted) <- c("chr", "start", "end")
```

Next, I will construct a GRanges object from this new 'peaksFormatted' object. GRanges objects work with Signac and other tools, storing genomic intervals (our ATAC peak regions).

```{r}
peaksGR <- makeGRangesFromDataFrame(peaksFormatted)
```

Now, we will assign chromosome lengths using our custom-forged chicken genome package.

Filter to chromsomes that are shared between the package and our GRanges object:

```{r}
common_chroms <- intersect(seqlevels(peaksGR),
  seqlevels(BSgenome.Ggallus.ensembl.GRCg7b))
```

Drop all other (non-shared) chromosomes from GRanges object:

```{r}
peaksFormatted <- keepSeqlevels(peaksGR,
  common_chroms, pruning.mode = "coarse")
```

Assign correct sequence lengths for shared chromosomes and call trim method to ensure ranges stay within boundaries:

```{r}
seqlengths(peaksGR) <- seqlengths(BSgenome.Ggallus.ensembl.GRCg7b)[common_chroms]
peaksGR <- trim(peaksGR)
```

## Individual Cluster ATAC Processing

The steps in the previous section have enabled us to create (and analyze) an "ATAC_IC" data assay. Peaks have been called separately for each cluster, rather than globally for all cells.

First, create an insertion count matrix (a sparse peak-by-cell matrix, storing how many fragments from each cell mapped to each peak).

```{r}
seu.counts <- FeatureMatrix(fragments = Fragments(seu),
                                   features = peaksGR,
                                   cells = colnames(seu))
```

Next, I will use that matrix to construct a new assay for Individual Cluster ATAC analysis.

```{r}
seu[["ATAC_IC"]] <- CreateChromatinAssay(seu.counts,
                                      sep = c(":", "-"),
                                      fragments = Fragments(seu),
                                      annotation = annotation)
```

Next, I will call Signac's Term Frequency–Inverse Document Frequency (TF-IDF) transformation method. This transformation helps adjust for differences in sequencing depth and highlights biologically meaningful variation in chromatin accessibility.

```{r}
DefaultAssay(seu) <- "ATAC_IC"
seu_merged <- RunTFIDF(seu, assay = "ATAC_IC")
```

I will select peaks with a score of at least 5:

```{r}
seu <- FindTopFeatures(seu, min.cutoff = 5)
```

Similarly to the previous ATAC analysis section, I will apply SVD to reduce dimensionality:

```{r}
seu_merged <- RunSVD(seu)
```

I'll again visualize the correlation between LSI/SVD component and sequencing depth:

```{r}
DepthCor(seu)
```

Visualize elbow plot for first 50 components:

```{r}
ElbowPlot(seu, reduction = "lsi", ndims = 50)
```

Construct KNN with features 2-30:

```{r}
seu <- FindNeighbors(object = seu, reduction = 'lsi', dims = 2:30)
```

```{r}
seu <- FindNeighbors(seu,
  reduction = "lsi", dims = 2:30, graph.name = c("ATAC_IC_nn", "ATAC_IC_snn"))
```

Again, run SLM clustering algorithm:

```{r}
seu <- FindClusters(object = seu,
                          algorithm = 3, cluster.name = "ATAC_IC_clusters",
                          graph.name = "ATAC_IC_snn")
```

Run UMAP:

```{r}
seu <- RunUMAP(seu, reduction = 'lsi', dims = 2:30,
                          assay = "ATAC_IC", slot = "data",
                          reduction.name = "umap.atacIC",
                          reduction.key = "atacicUMAP_")
```

Visualize UMAP with clusters:

```{r}
DimPlot(seu, reduction = "umap.atacIC", group.by = "ATAC_IC_clusters")
```

## Constructing Gene Activity Assay

Next, I am going to create an assay for "gene activity". This will combine information from the ATAC_IC and RNA assays.

First, construct the Gene Activity assay using the Gene Activity Counts from the ATAC_IC assay:

```{r}
seu[['Gene_Activity']] <- CreateAssayObject(
  counts = GeneActivity(seu, assay = "ATAC_IC"))
```

Next, ensure the ATAC_IC assay is being used and perform log-normalization.

```{r}
seu_merged <- NormalizeData(object = seu, assay = 'Gene_Activity',
  normalization.method = 'LogNormalize', scale.factor = median(seu$nCount_ATAC_IC))
```

Next, I will construct a Weighted Shared Nearest Neighbor (WSNN) graph with the FindMultiModalNeighbors method. This is an integrated graph that combines multiple modalities (in this case, assays). Thus, I need to make sure I set the RNA assay as default first. Note that I list two types of reduction and both of their relevant dimensions.

```{r}
DefaultAssay(seu) <- "RNA"
seu <- FindMultiModalNeighbors(object = seu,
  reduction.list = list("pca", "lsi"), dims.list = list(1:50, 2:30))
```

Run SLM clustering on the WSNN graph:

```{r}
seu <- FindClusters(seu, graph.name = "wsnn", algorithm = 3)
```

Save WSNN clusters to a separate metadata field:

```{r}
seu$WSNN_clusters <- seu$seurat_clusters
```

Run UMAP:

```{r}
seu <- RunUMAP(object = seu,
                          reduction.name = "umap.wnn",
                          nn.name = "weighted.nn")
```

Visualize UMAP:

```{r}
DimPlot(seu, reduction = "umap.wnn", group.by = "WSNN_clusters")
```

## Notebook Conclusions

In this notebook, we have done clustering and UMAP reduction for 4 different assays. Here is an explanation of each:

**scRNA-seq:** Using PCA to reduce dimensionality of gene expression data and cluster based on transcriptional similarity. This method groups cells by mRNA expression levels, identifying transcriptionally distinct cell states.

**ATAC-seq:** Performed dimensionality reduction using LSI on the raw ATAC peak matrix, followed by clustering and UMAP. This reflects differences in genome accessibility patterns, highlighting regulatory landscape variation between cells.

**Individual Cluster ATAC-seq:** Redefine ATAC peak features by calling peaks per RNA cluster and used this refined set for LSI-based dimensionality reduction and clustering. This approach provides more targeted chromatin accessibility profiles, enhancing sensitivity to biologically meaningful variation.

**Gene Activity Clustering:** Created a GeneActivity assay from ATAC_IC, normalized it, and combined PCA (RNA) and LSI (ATAC_IC) via FindMultiModalNeighbors. This integrative method jointly considers gene expression and regulatory accessibility to define cell identity with higher fidelity.

I will save the current state of the Seurat object and session info:

```{r}
output_dir <- '/Users/benzazycki/Documents/Research/ChickenEye/Outputs/notebook_3/'
saveRDS(seu_merged, file = paste0(output_dir, "seu_clustered.rds"))
writeLines(capture.output(sessionInfo()), paste0(output_dir, "session_info.txt"))
```
